name: CI

on:
  push:
  pull_request:

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.9", "3.10", "3.11", "3.12"]

    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Setup test environment
      run: |
        cp .env.test .env
    
    - name: Run unit tests
      run: |
        pytest tests/ -v -m "unit" --cov=src --cov-report=xml --cov-report=term-missing
    
    - name: Run integration tests (no network)
      run: |
        pytest tests/ -v -m "integration and not network" --cov=src --cov-append --cov-report=xml --cov-report=term-missing
    
    - name: Run mock tests
      run: |
        pytest tests/ -v -m "mock" --cov=src --cov-append --cov-report=xml --cov-report=term-missing --cov-report=json
    
    - name: Update coverage badge
      if: matrix.python-version == '3.11' && github.ref == 'refs/heads/main'
      run: |
        # Extract coverage percentage from coverage.json
        COVERAGE=$(python -c "import json; data=json.load(open('coverage.json')); print(f'{data[\"totals\"][\"percent_covered\"]:.0f}')")
        echo "Coverage: ${COVERAGE}%"
        
        # Determine badge color based on coverage
        if [ "$COVERAGE" -ge 80 ]; then
          COLOR="brightgreen"
        elif [ "$COVERAGE" -ge 60 ]; then
          COLOR="yellow"
        else
          COLOR="red"
        fi
        
        # Update README badge
        sed -i "s/!\[Coverage\](https:\/\/img\.shields\.io\/badge\/coverage-[0-9]*%25-[a-z]*)/![Coverage](https:\/\/img.shields.io\/badge\/coverage-${COVERAGE}%25-${COLOR})/" README.md
    
    - name: Comment PR with coverage
      if: matrix.python-version == '3.11' && github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const { execSync } = require('child_process');
          
          // Read coverage data
          const coverage = JSON.parse(fs.readFileSync('coverage.json', 'utf8'));
          const totalCoverage = Math.round(coverage.totals.percent_covered);
          
          // Fetch the base branch and get PR diff to find new/modified lines
          try {
            execSync(`git fetch origin ${context.payload.pull_request.base.ref}:${context.payload.pull_request.base.ref}`);
          } catch (e) {
            console.log('Branch may already exist, continuing...');
          }
          
          const diff = execSync(`git diff ${context.payload.pull_request.base.sha}...${context.payload.pull_request.head.sha} --unified=0`).toString();
          
          // Parse diff to extract new lines by file
          const newLines = {};
          let currentFile = null;
          
          diff.split('\n').forEach(line => {
            if (line.startsWith('+++')) {
              const match = line.match(/\+\+\+ b\/(.+)/);
              if (match) currentFile = match[1];
            } else if (line.startsWith('@@') && currentFile) {
              const match = line.match(/@@ -\d+(?:,\d+)? \+(\d+)(?:,(\d+))? @@/);
              if (match) {
                const startLine = parseInt(match[1]);
                const lineCount = parseInt(match[2] || '1');
                if (!newLines[currentFile]) newLines[currentFile] = [];
                for (let i = 0; i < lineCount; i++) {
                  newLines[currentFile].push(startLine + i);
                }
              }
            }
          });
          
          // Calculate coverage for new lines only
          let newCodeCovered = 0;
          let newCodeTotal = 0;
          const newFileDetails = [];
          
          Object.entries(newLines).forEach(([file, lines]) => {
            if (coverage.files[file]) {
              const fileData = coverage.files[file];
              let fileCovered = 0;
              let fileTotal = 0;
              
              lines.forEach(lineNum => {
                if (fileData.executed_lines.includes(lineNum)) {
                  fileCovered++;
                  newCodeCovered++;
                } else if (fileData.missing_lines.includes(lineNum)) {
                  // Line is executable but not covered
                  fileTotal++;
                  newCodeTotal++;
                } else if (fileData.executed_lines.includes(lineNum) || 
                          Object.keys(fileData.summary).length > 0) {
                  // Line is covered
                  fileCovered++;
                  newCodeCovered++;
                }
                fileTotal++;
                newCodeTotal++;
              });
              
              if (fileTotal > 0) {
                newFileDetails.push({
                  file: file.replace('src/', ''),
                  coverage: Math.round((fileCovered / fileTotal) * 100),
                  lines: fileTotal
                });
              }
            }
          });
          
          const newCodeCoverage = newCodeTotal > 0 ? Math.round((newCodeCovered / newCodeTotal) * 100) : 100;
          
          // Determine emoji and status for overall coverage
          let emoji = '🔴';
          let status = 'needs improvement';
          if (totalCoverage >= 80) {
            emoji = '🟢';
            status = 'excellent';
          } else if (totalCoverage >= 60) {
            emoji = '🟡';
            status = 'good';
          }
          
          // Determine emoji for new code coverage
          let newCodeEmoji = '🔴';
          let newCodeStatus = 'needs improvement';
          if (newCodeCoverage >= 80) {
            newCodeEmoji = '🟢';
            newCodeStatus = 'excellent';
          } else if (newCodeCoverage >= 60) {
            newCodeEmoji = '🟡';
            newCodeStatus = 'good';
          }
          
          // Get detailed coverage by file (overall)
          const fileDetails = Object.entries(coverage.files)
            .map(([file, data]) => ({
              file: file.replace('src/', ''),
              coverage: Math.round(data.summary.percent_covered)
            }))
            .sort((a, b) => a.coverage - b.coverage)
            .slice(0, 10);
          
          const detailsTable = fileDetails
            .map(({file, coverage}) => `| ${file} | ${coverage}% |`)
            .join('\n');
          
          // New code details table
          const newCodeTable = newFileDetails.length > 0 ? 
            newFileDetails
              .sort((a, b) => a.coverage - b.coverage)
              .map(({file, coverage, lines}) => `| ${file} | ${coverage}% | ${lines} lines |`)
              .join('\n') : 
            '| No new executable code detected | - | - |';
          
          const comment = `## ${emoji} Test Coverage Report
          
          **Overall Coverage: ${totalCoverage}% (${status})**  
          **New Code Coverage: ${newCodeEmoji} ${newCodeCoverage}% (${newCodeStatus})**
          
          ${newCodeTotal > 0 ? `📝 **${newCodeTotal} new/modified lines** analyzed` : '📝 **No new executable lines** detected'}
          
          <details>
          <summary>🆕 New Code Coverage by File</summary>
          
          | File | Coverage | Lines |
          |------|----------|-------|
          ${newCodeTable}
          
          </details>
          
          <details>
          <summary>📊 Overall Coverage by File (lowest coverage first)</summary>
          
          | File | Coverage |
          |------|----------|
          ${detailsTable}
          
          </details>
          
          > **Coverage targets:** 80% for excellent, 60% for good  
          > **Tip:** Focus on improving coverage for new code to maintain quality
          `;
          
          github.rest.issues.createComment({
            issue_number: context.payload.pull_request.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });

    - name: Commit coverage badge update
      if: matrix.python-version == '3.11' && github.ref == 'refs/heads/main'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        if git diff --quiet README.md; then
          echo "No coverage badge changes to commit"
        else
          git add README.md
          git commit -m "Update coverage badge [skip ci]"
          git push
        fi
    
    # - name: Upload coverage reports to Codecov
    #   uses: codecov/codecov-action@v5
    #   with:
    #     token: ${{ secrets.CODECOV_TOKEN }}
    #     files: ./coverage.xml
    #     flags: unittests
    #     name: codecov-umbrella
    #     fail_ci_if_error: false

  test-slow:
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python 3.11
      uses: actions/setup-python@v4
      with:
        python-version: "3.11"
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Run slow/network tests
      run: |
        pytest tests/ -v -m "slow or network" --tb=short
      continue-on-error: true  # Network tests may fail due to external dependencies

